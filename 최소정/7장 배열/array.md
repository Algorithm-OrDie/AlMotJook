# 07. 배열

배열: 값 또는 변수 엘리먼트의 집합으로 구성된 구조. 하나 이상의 인덱스 또는 키로 식별됨.

- 자료구조
    - 연속 방식 - 메모리 공간 기반 → 배열
    - 연결 방식 - 포인터 기반 → 연결 리스트
    - ADT의 실제 구현 대부분은 배열 또는 연결 리스트를 기반으로 함
        
        예) 스택은 연결 리스트, 큐는 배열
        
- (C언어 기준) 배열
    
    : 크기를 지정하고 해당 크기만큼의 연속된 메모리 공간을 할당받는 작업을 수행하는 자료형. 크기가 고정되어 배열 크기 변경 불가능
    
    - (최신 시스템과 컴파일러 기준) int 사이즈 4바이트, 메모리에 대한 접근 바이트 단위, 즉 가리키는 주소 1바이트마다 1씩 증가
    - int형 배열 → 각 엘리먼트는 4바이트, 배열의 주소 4씩 증가
    - 배열은 어느 위치에나 O(1)에 조회 가능 → 즉시 주소를 계산하여 해당 메모리에 배치되어 있는 값 읽어옴
- 동적 배열
    
    : 크기를 지정하지 않고 자동으로 리사이징하는 배열
    
    - 자바 `ArrayList`, C++ `std::vector`, 파이썬 리스트 (대부분의 동적 프로그래밍 언어는 정적 배열 자체가 없음. 파이썬도 마찬가지)
    - 원리 - 미리 초깃값을 작게 잡아 배열 생성 → 데이터가 추가되면서 꽉 채워지면 늘려주고 모두 복사 ⇒ “더블링”
    - 파이썬의 더블링 구조
        
        `0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...` 순으로 재할당
        
        그로스 팩터(성장 인자) → 재할당 비율. 파이썬은 초반 2배씩 늘리지만 전체적으로 약 1.125배로, 다른 언어에 비해 다소 조금만 늘려가는 형태.
        
        자바 `ArrayList`는 1.5배, C++의 `std::vector`나 루비는 2배
        
- 분할 상환 분석에 따른 시간 복잡도
    - 동적 배열은 정적 배열과 달리 크기를 지정할 필요가 없어 매우 편리하게 활용 가능
    - 조회 또한 기존의 배열과 동일하게 O(1)에 가능
    - 그러나 더블링이 필요할 만큼 공간이 차게 되면, 새로운 메모리 공간에 더 큰 크기의 배열을 할당하고 기존 데이터를 복사하는 작업 필요
        
        ⇒ O(n) 비용 발생
        
    - 최악의 경우 삽입 시 O(n)이지만 자주 일어나는 일은 아니므로 분할 상환 분석에 따른 입력 시간은 여전히 O(1)
